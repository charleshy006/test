// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef PROTOBUF_Login_2eproto__INCLUDED
#define PROTOBUF_Login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ModID.pb.h"
// @@protoc_insertion_point(includes)

namespace Login {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Login_2eproto();
void protobuf_AssignDesc_Login_2eproto();
void protobuf_ShutdownFile_Login_2eproto();

class ReqLogin;
class RetLoginSucess;
class LoginError;
class ReqLoginGate;
class stReqServerTime;
class stRetServerTime;
class stAutoLoginGate;
class stNotifyRelogin;
class stQueryPingValue;
class stReqClientTime;
class stSendClient2Svr;
class stNotifyIsNewAccount;

enum ReqLogin_ProtoModID {
  ReqLogin_ProtoModID_ModID = 1
};
bool ReqLogin_ProtoModID_IsValid(int value);
const ReqLogin_ProtoModID ReqLogin_ProtoModID_ProtoModID_MIN = ReqLogin_ProtoModID_ModID;
const ReqLogin_ProtoModID ReqLogin_ProtoModID_ProtoModID_MAX = ReqLogin_ProtoModID_ModID;
const int ReqLogin_ProtoModID_ProtoModID_ARRAYSIZE = ReqLogin_ProtoModID_ProtoModID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReqLogin_ProtoModID_descriptor();
inline const ::std::string& ReqLogin_ProtoModID_Name(ReqLogin_ProtoModID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqLogin_ProtoModID_descriptor(), value);
}
inline bool ReqLogin_ProtoModID_Parse(
    const ::std::string& name, ReqLogin_ProtoModID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqLogin_ProtoModID>(
    ReqLogin_ProtoModID_descriptor(), name, value);
}
enum ReqLogin_ProtoFunID {
  ReqLogin_ProtoFunID_FunID = 1
};
bool ReqLogin_ProtoFunID_IsValid(int value);
const ReqLogin_ProtoFunID ReqLogin_ProtoFunID_ProtoFunID_MIN = ReqLogin_ProtoFunID_FunID;
const ReqLogin_ProtoFunID ReqLogin_ProtoFunID_ProtoFunID_MAX = ReqLogin_ProtoFunID_FunID;
const int ReqLogin_ProtoFunID_ProtoFunID_ARRAYSIZE = ReqLogin_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReqLogin_ProtoFunID_descriptor();
inline const ::std::string& ReqLogin_ProtoFunID_Name(ReqLogin_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqLogin_ProtoFunID_descriptor(), value);
}
inline bool ReqLogin_ProtoFunID_Parse(
    const ::std::string& name, ReqLogin_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqLogin_ProtoFunID>(
    ReqLogin_ProtoFunID_descriptor(), name, value);
}
enum RetLoginSucess_ProtoModID {
  RetLoginSucess_ProtoModID_ModID = 1
};
bool RetLoginSucess_ProtoModID_IsValid(int value);
const RetLoginSucess_ProtoModID RetLoginSucess_ProtoModID_ProtoModID_MIN = RetLoginSucess_ProtoModID_ModID;
const RetLoginSucess_ProtoModID RetLoginSucess_ProtoModID_ProtoModID_MAX = RetLoginSucess_ProtoModID_ModID;
const int RetLoginSucess_ProtoModID_ProtoModID_ARRAYSIZE = RetLoginSucess_ProtoModID_ProtoModID_MAX + 1;

const ::google::protobuf::EnumDescriptor* RetLoginSucess_ProtoModID_descriptor();
inline const ::std::string& RetLoginSucess_ProtoModID_Name(RetLoginSucess_ProtoModID value) {
  return ::google::protobuf::internal::NameOfEnum(
    RetLoginSucess_ProtoModID_descriptor(), value);
}
inline bool RetLoginSucess_ProtoModID_Parse(
    const ::std::string& name, RetLoginSucess_ProtoModID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RetLoginSucess_ProtoModID>(
    RetLoginSucess_ProtoModID_descriptor(), name, value);
}
enum RetLoginSucess_ProtoFunID {
  RetLoginSucess_ProtoFunID_FunID = 2
};
bool RetLoginSucess_ProtoFunID_IsValid(int value);
const RetLoginSucess_ProtoFunID RetLoginSucess_ProtoFunID_ProtoFunID_MIN = RetLoginSucess_ProtoFunID_FunID;
const RetLoginSucess_ProtoFunID RetLoginSucess_ProtoFunID_ProtoFunID_MAX = RetLoginSucess_ProtoFunID_FunID;
const int RetLoginSucess_ProtoFunID_ProtoFunID_ARRAYSIZE = RetLoginSucess_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* RetLoginSucess_ProtoFunID_descriptor();
inline const ::std::string& RetLoginSucess_ProtoFunID_Name(RetLoginSucess_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    RetLoginSucess_ProtoFunID_descriptor(), value);
}
inline bool RetLoginSucess_ProtoFunID_Parse(
    const ::std::string& name, RetLoginSucess_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RetLoginSucess_ProtoFunID>(
    RetLoginSucess_ProtoFunID_descriptor(), name, value);
}
enum LoginError_ErrorType {
  LoginError_ErrorType_PASSWORD_WRONG = 1,
  LoginError_ErrorType_HAS_LOGIN_IN = 2,
  LoginError_ErrorType_OTHER = 3,
  LoginError_ErrorType_LOGIN_IN_OTHER_PLACE = 4,
  LoginError_ErrorType_LOGIN_VERSION_TOO_LOW = 5
};
bool LoginError_ErrorType_IsValid(int value);
const LoginError_ErrorType LoginError_ErrorType_ErrorType_MIN = LoginError_ErrorType_PASSWORD_WRONG;
const LoginError_ErrorType LoginError_ErrorType_ErrorType_MAX = LoginError_ErrorType_LOGIN_VERSION_TOO_LOW;
const int LoginError_ErrorType_ErrorType_ARRAYSIZE = LoginError_ErrorType_ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginError_ErrorType_descriptor();
inline const ::std::string& LoginError_ErrorType_Name(LoginError_ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginError_ErrorType_descriptor(), value);
}
inline bool LoginError_ErrorType_Parse(
    const ::std::string& name, LoginError_ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginError_ErrorType>(
    LoginError_ErrorType_descriptor(), name, value);
}
enum LoginError_ProtoID {
  LoginError_ProtoID_ModID = 1
};
bool LoginError_ProtoID_IsValid(int value);
const LoginError_ProtoID LoginError_ProtoID_ProtoID_MIN = LoginError_ProtoID_ModID;
const LoginError_ProtoID LoginError_ProtoID_ProtoID_MAX = LoginError_ProtoID_ModID;
const int LoginError_ProtoID_ProtoID_ARRAYSIZE = LoginError_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginError_ProtoID_descriptor();
inline const ::std::string& LoginError_ProtoID_Name(LoginError_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginError_ProtoID_descriptor(), value);
}
inline bool LoginError_ProtoID_Parse(
    const ::std::string& name, LoginError_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginError_ProtoID>(
    LoginError_ProtoID_descriptor(), name, value);
}
enum LoginError_ProtoFunID {
  LoginError_ProtoFunID_FunID = 3
};
bool LoginError_ProtoFunID_IsValid(int value);
const LoginError_ProtoFunID LoginError_ProtoFunID_ProtoFunID_MIN = LoginError_ProtoFunID_FunID;
const LoginError_ProtoFunID LoginError_ProtoFunID_ProtoFunID_MAX = LoginError_ProtoFunID_FunID;
const int LoginError_ProtoFunID_ProtoFunID_ARRAYSIZE = LoginError_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginError_ProtoFunID_descriptor();
inline const ::std::string& LoginError_ProtoFunID_Name(LoginError_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginError_ProtoFunID_descriptor(), value);
}
inline bool LoginError_ProtoFunID_Parse(
    const ::std::string& name, LoginError_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginError_ProtoFunID>(
    LoginError_ProtoFunID_descriptor(), name, value);
}
enum ReqLoginGate_ProtoID {
  ReqLoginGate_ProtoID_ModID = 1
};
bool ReqLoginGate_ProtoID_IsValid(int value);
const ReqLoginGate_ProtoID ReqLoginGate_ProtoID_ProtoID_MIN = ReqLoginGate_ProtoID_ModID;
const ReqLoginGate_ProtoID ReqLoginGate_ProtoID_ProtoID_MAX = ReqLoginGate_ProtoID_ModID;
const int ReqLoginGate_ProtoID_ProtoID_ARRAYSIZE = ReqLoginGate_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReqLoginGate_ProtoID_descriptor();
inline const ::std::string& ReqLoginGate_ProtoID_Name(ReqLoginGate_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqLoginGate_ProtoID_descriptor(), value);
}
inline bool ReqLoginGate_ProtoID_Parse(
    const ::std::string& name, ReqLoginGate_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqLoginGate_ProtoID>(
    ReqLoginGate_ProtoID_descriptor(), name, value);
}
enum ReqLoginGate_ProtoFunID {
  ReqLoginGate_ProtoFunID_FunID = 4
};
bool ReqLoginGate_ProtoFunID_IsValid(int value);
const ReqLoginGate_ProtoFunID ReqLoginGate_ProtoFunID_ProtoFunID_MIN = ReqLoginGate_ProtoFunID_FunID;
const ReqLoginGate_ProtoFunID ReqLoginGate_ProtoFunID_ProtoFunID_MAX = ReqLoginGate_ProtoFunID_FunID;
const int ReqLoginGate_ProtoFunID_ProtoFunID_ARRAYSIZE = ReqLoginGate_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReqLoginGate_ProtoFunID_descriptor();
inline const ::std::string& ReqLoginGate_ProtoFunID_Name(ReqLoginGate_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReqLoginGate_ProtoFunID_descriptor(), value);
}
inline bool ReqLoginGate_ProtoFunID_Parse(
    const ::std::string& name, ReqLoginGate_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReqLoginGate_ProtoFunID>(
    ReqLoginGate_ProtoFunID_descriptor(), name, value);
}
enum stReqServerTime_ProtoID {
  stReqServerTime_ProtoID_ModID = 1
};
bool stReqServerTime_ProtoID_IsValid(int value);
const stReqServerTime_ProtoID stReqServerTime_ProtoID_ProtoID_MIN = stReqServerTime_ProtoID_ModID;
const stReqServerTime_ProtoID stReqServerTime_ProtoID_ProtoID_MAX = stReqServerTime_ProtoID_ModID;
const int stReqServerTime_ProtoID_ProtoID_ARRAYSIZE = stReqServerTime_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stReqServerTime_ProtoID_descriptor();
inline const ::std::string& stReqServerTime_ProtoID_Name(stReqServerTime_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stReqServerTime_ProtoID_descriptor(), value);
}
inline bool stReqServerTime_ProtoID_Parse(
    const ::std::string& name, stReqServerTime_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stReqServerTime_ProtoID>(
    stReqServerTime_ProtoID_descriptor(), name, value);
}
enum stReqServerTime_ProtoFunID {
  stReqServerTime_ProtoFunID_FunID = 5
};
bool stReqServerTime_ProtoFunID_IsValid(int value);
const stReqServerTime_ProtoFunID stReqServerTime_ProtoFunID_ProtoFunID_MIN = stReqServerTime_ProtoFunID_FunID;
const stReqServerTime_ProtoFunID stReqServerTime_ProtoFunID_ProtoFunID_MAX = stReqServerTime_ProtoFunID_FunID;
const int stReqServerTime_ProtoFunID_ProtoFunID_ARRAYSIZE = stReqServerTime_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stReqServerTime_ProtoFunID_descriptor();
inline const ::std::string& stReqServerTime_ProtoFunID_Name(stReqServerTime_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stReqServerTime_ProtoFunID_descriptor(), value);
}
inline bool stReqServerTime_ProtoFunID_Parse(
    const ::std::string& name, stReqServerTime_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stReqServerTime_ProtoFunID>(
    stReqServerTime_ProtoFunID_descriptor(), name, value);
}
enum stRetServerTime_ProtoID {
  stRetServerTime_ProtoID_ModID = 1
};
bool stRetServerTime_ProtoID_IsValid(int value);
const stRetServerTime_ProtoID stRetServerTime_ProtoID_ProtoID_MIN = stRetServerTime_ProtoID_ModID;
const stRetServerTime_ProtoID stRetServerTime_ProtoID_ProtoID_MAX = stRetServerTime_ProtoID_ModID;
const int stRetServerTime_ProtoID_ProtoID_ARRAYSIZE = stRetServerTime_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stRetServerTime_ProtoID_descriptor();
inline const ::std::string& stRetServerTime_ProtoID_Name(stRetServerTime_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stRetServerTime_ProtoID_descriptor(), value);
}
inline bool stRetServerTime_ProtoID_Parse(
    const ::std::string& name, stRetServerTime_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stRetServerTime_ProtoID>(
    stRetServerTime_ProtoID_descriptor(), name, value);
}
enum stRetServerTime_ProtoFunID {
  stRetServerTime_ProtoFunID_FunID = 6
};
bool stRetServerTime_ProtoFunID_IsValid(int value);
const stRetServerTime_ProtoFunID stRetServerTime_ProtoFunID_ProtoFunID_MIN = stRetServerTime_ProtoFunID_FunID;
const stRetServerTime_ProtoFunID stRetServerTime_ProtoFunID_ProtoFunID_MAX = stRetServerTime_ProtoFunID_FunID;
const int stRetServerTime_ProtoFunID_ProtoFunID_ARRAYSIZE = stRetServerTime_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stRetServerTime_ProtoFunID_descriptor();
inline const ::std::string& stRetServerTime_ProtoFunID_Name(stRetServerTime_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stRetServerTime_ProtoFunID_descriptor(), value);
}
inline bool stRetServerTime_ProtoFunID_Parse(
    const ::std::string& name, stRetServerTime_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stRetServerTime_ProtoFunID>(
    stRetServerTime_ProtoFunID_descriptor(), name, value);
}
enum stAutoLoginGate_ProtoID {
  stAutoLoginGate_ProtoID_ModID = 1
};
bool stAutoLoginGate_ProtoID_IsValid(int value);
const stAutoLoginGate_ProtoID stAutoLoginGate_ProtoID_ProtoID_MIN = stAutoLoginGate_ProtoID_ModID;
const stAutoLoginGate_ProtoID stAutoLoginGate_ProtoID_ProtoID_MAX = stAutoLoginGate_ProtoID_ModID;
const int stAutoLoginGate_ProtoID_ProtoID_ARRAYSIZE = stAutoLoginGate_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stAutoLoginGate_ProtoID_descriptor();
inline const ::std::string& stAutoLoginGate_ProtoID_Name(stAutoLoginGate_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stAutoLoginGate_ProtoID_descriptor(), value);
}
inline bool stAutoLoginGate_ProtoID_Parse(
    const ::std::string& name, stAutoLoginGate_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stAutoLoginGate_ProtoID>(
    stAutoLoginGate_ProtoID_descriptor(), name, value);
}
enum stAutoLoginGate_ProtoFunID {
  stAutoLoginGate_ProtoFunID_FunID = 7
};
bool stAutoLoginGate_ProtoFunID_IsValid(int value);
const stAutoLoginGate_ProtoFunID stAutoLoginGate_ProtoFunID_ProtoFunID_MIN = stAutoLoginGate_ProtoFunID_FunID;
const stAutoLoginGate_ProtoFunID stAutoLoginGate_ProtoFunID_ProtoFunID_MAX = stAutoLoginGate_ProtoFunID_FunID;
const int stAutoLoginGate_ProtoFunID_ProtoFunID_ARRAYSIZE = stAutoLoginGate_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stAutoLoginGate_ProtoFunID_descriptor();
inline const ::std::string& stAutoLoginGate_ProtoFunID_Name(stAutoLoginGate_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stAutoLoginGate_ProtoFunID_descriptor(), value);
}
inline bool stAutoLoginGate_ProtoFunID_Parse(
    const ::std::string& name, stAutoLoginGate_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stAutoLoginGate_ProtoFunID>(
    stAutoLoginGate_ProtoFunID_descriptor(), name, value);
}
enum stNotifyRelogin_ProtoID {
  stNotifyRelogin_ProtoID_ModID = 1
};
bool stNotifyRelogin_ProtoID_IsValid(int value);
const stNotifyRelogin_ProtoID stNotifyRelogin_ProtoID_ProtoID_MIN = stNotifyRelogin_ProtoID_ModID;
const stNotifyRelogin_ProtoID stNotifyRelogin_ProtoID_ProtoID_MAX = stNotifyRelogin_ProtoID_ModID;
const int stNotifyRelogin_ProtoID_ProtoID_ARRAYSIZE = stNotifyRelogin_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stNotifyRelogin_ProtoID_descriptor();
inline const ::std::string& stNotifyRelogin_ProtoID_Name(stNotifyRelogin_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stNotifyRelogin_ProtoID_descriptor(), value);
}
inline bool stNotifyRelogin_ProtoID_Parse(
    const ::std::string& name, stNotifyRelogin_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stNotifyRelogin_ProtoID>(
    stNotifyRelogin_ProtoID_descriptor(), name, value);
}
enum stNotifyRelogin_ProtoFunID {
  stNotifyRelogin_ProtoFunID_FunID = 8
};
bool stNotifyRelogin_ProtoFunID_IsValid(int value);
const stNotifyRelogin_ProtoFunID stNotifyRelogin_ProtoFunID_ProtoFunID_MIN = stNotifyRelogin_ProtoFunID_FunID;
const stNotifyRelogin_ProtoFunID stNotifyRelogin_ProtoFunID_ProtoFunID_MAX = stNotifyRelogin_ProtoFunID_FunID;
const int stNotifyRelogin_ProtoFunID_ProtoFunID_ARRAYSIZE = stNotifyRelogin_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stNotifyRelogin_ProtoFunID_descriptor();
inline const ::std::string& stNotifyRelogin_ProtoFunID_Name(stNotifyRelogin_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stNotifyRelogin_ProtoFunID_descriptor(), value);
}
inline bool stNotifyRelogin_ProtoFunID_Parse(
    const ::std::string& name, stNotifyRelogin_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stNotifyRelogin_ProtoFunID>(
    stNotifyRelogin_ProtoFunID_descriptor(), name, value);
}
enum stQueryPingValue_ProtoID {
  stQueryPingValue_ProtoID_ModID = 1
};
bool stQueryPingValue_ProtoID_IsValid(int value);
const stQueryPingValue_ProtoID stQueryPingValue_ProtoID_ProtoID_MIN = stQueryPingValue_ProtoID_ModID;
const stQueryPingValue_ProtoID stQueryPingValue_ProtoID_ProtoID_MAX = stQueryPingValue_ProtoID_ModID;
const int stQueryPingValue_ProtoID_ProtoID_ARRAYSIZE = stQueryPingValue_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stQueryPingValue_ProtoID_descriptor();
inline const ::std::string& stQueryPingValue_ProtoID_Name(stQueryPingValue_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stQueryPingValue_ProtoID_descriptor(), value);
}
inline bool stQueryPingValue_ProtoID_Parse(
    const ::std::string& name, stQueryPingValue_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stQueryPingValue_ProtoID>(
    stQueryPingValue_ProtoID_descriptor(), name, value);
}
enum stQueryPingValue_ProtoFunID {
  stQueryPingValue_ProtoFunID_FunID = 9
};
bool stQueryPingValue_ProtoFunID_IsValid(int value);
const stQueryPingValue_ProtoFunID stQueryPingValue_ProtoFunID_ProtoFunID_MIN = stQueryPingValue_ProtoFunID_FunID;
const stQueryPingValue_ProtoFunID stQueryPingValue_ProtoFunID_ProtoFunID_MAX = stQueryPingValue_ProtoFunID_FunID;
const int stQueryPingValue_ProtoFunID_ProtoFunID_ARRAYSIZE = stQueryPingValue_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stQueryPingValue_ProtoFunID_descriptor();
inline const ::std::string& stQueryPingValue_ProtoFunID_Name(stQueryPingValue_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stQueryPingValue_ProtoFunID_descriptor(), value);
}
inline bool stQueryPingValue_ProtoFunID_Parse(
    const ::std::string& name, stQueryPingValue_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stQueryPingValue_ProtoFunID>(
    stQueryPingValue_ProtoFunID_descriptor(), name, value);
}
enum stReqClientTime_ProtoID {
  stReqClientTime_ProtoID_ModID = 1
};
bool stReqClientTime_ProtoID_IsValid(int value);
const stReqClientTime_ProtoID stReqClientTime_ProtoID_ProtoID_MIN = stReqClientTime_ProtoID_ModID;
const stReqClientTime_ProtoID stReqClientTime_ProtoID_ProtoID_MAX = stReqClientTime_ProtoID_ModID;
const int stReqClientTime_ProtoID_ProtoID_ARRAYSIZE = stReqClientTime_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stReqClientTime_ProtoID_descriptor();
inline const ::std::string& stReqClientTime_ProtoID_Name(stReqClientTime_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stReqClientTime_ProtoID_descriptor(), value);
}
inline bool stReqClientTime_ProtoID_Parse(
    const ::std::string& name, stReqClientTime_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stReqClientTime_ProtoID>(
    stReqClientTime_ProtoID_descriptor(), name, value);
}
enum stReqClientTime_ProtoFunID {
  stReqClientTime_ProtoFunID_FunID = 10
};
bool stReqClientTime_ProtoFunID_IsValid(int value);
const stReqClientTime_ProtoFunID stReqClientTime_ProtoFunID_ProtoFunID_MIN = stReqClientTime_ProtoFunID_FunID;
const stReqClientTime_ProtoFunID stReqClientTime_ProtoFunID_ProtoFunID_MAX = stReqClientTime_ProtoFunID_FunID;
const int stReqClientTime_ProtoFunID_ProtoFunID_ARRAYSIZE = stReqClientTime_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stReqClientTime_ProtoFunID_descriptor();
inline const ::std::string& stReqClientTime_ProtoFunID_Name(stReqClientTime_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stReqClientTime_ProtoFunID_descriptor(), value);
}
inline bool stReqClientTime_ProtoFunID_Parse(
    const ::std::string& name, stReqClientTime_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stReqClientTime_ProtoFunID>(
    stReqClientTime_ProtoFunID_descriptor(), name, value);
}
enum stSendClient2Svr_ProtoID {
  stSendClient2Svr_ProtoID_ModID = 1
};
bool stSendClient2Svr_ProtoID_IsValid(int value);
const stSendClient2Svr_ProtoID stSendClient2Svr_ProtoID_ProtoID_MIN = stSendClient2Svr_ProtoID_ModID;
const stSendClient2Svr_ProtoID stSendClient2Svr_ProtoID_ProtoID_MAX = stSendClient2Svr_ProtoID_ModID;
const int stSendClient2Svr_ProtoID_ProtoID_ARRAYSIZE = stSendClient2Svr_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stSendClient2Svr_ProtoID_descriptor();
inline const ::std::string& stSendClient2Svr_ProtoID_Name(stSendClient2Svr_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stSendClient2Svr_ProtoID_descriptor(), value);
}
inline bool stSendClient2Svr_ProtoID_Parse(
    const ::std::string& name, stSendClient2Svr_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stSendClient2Svr_ProtoID>(
    stSendClient2Svr_ProtoID_descriptor(), name, value);
}
enum stSendClient2Svr_ProtoFunID {
  stSendClient2Svr_ProtoFunID_FunID = 11
};
bool stSendClient2Svr_ProtoFunID_IsValid(int value);
const stSendClient2Svr_ProtoFunID stSendClient2Svr_ProtoFunID_ProtoFunID_MIN = stSendClient2Svr_ProtoFunID_FunID;
const stSendClient2Svr_ProtoFunID stSendClient2Svr_ProtoFunID_ProtoFunID_MAX = stSendClient2Svr_ProtoFunID_FunID;
const int stSendClient2Svr_ProtoFunID_ProtoFunID_ARRAYSIZE = stSendClient2Svr_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stSendClient2Svr_ProtoFunID_descriptor();
inline const ::std::string& stSendClient2Svr_ProtoFunID_Name(stSendClient2Svr_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stSendClient2Svr_ProtoFunID_descriptor(), value);
}
inline bool stSendClient2Svr_ProtoFunID_Parse(
    const ::std::string& name, stSendClient2Svr_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stSendClient2Svr_ProtoFunID>(
    stSendClient2Svr_ProtoFunID_descriptor(), name, value);
}
enum stNotifyIsNewAccount_ProtoID {
  stNotifyIsNewAccount_ProtoID_ModID = 1
};
bool stNotifyIsNewAccount_ProtoID_IsValid(int value);
const stNotifyIsNewAccount_ProtoID stNotifyIsNewAccount_ProtoID_ProtoID_MIN = stNotifyIsNewAccount_ProtoID_ModID;
const stNotifyIsNewAccount_ProtoID stNotifyIsNewAccount_ProtoID_ProtoID_MAX = stNotifyIsNewAccount_ProtoID_ModID;
const int stNotifyIsNewAccount_ProtoID_ProtoID_ARRAYSIZE = stNotifyIsNewAccount_ProtoID_ProtoID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stNotifyIsNewAccount_ProtoID_descriptor();
inline const ::std::string& stNotifyIsNewAccount_ProtoID_Name(stNotifyIsNewAccount_ProtoID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stNotifyIsNewAccount_ProtoID_descriptor(), value);
}
inline bool stNotifyIsNewAccount_ProtoID_Parse(
    const ::std::string& name, stNotifyIsNewAccount_ProtoID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stNotifyIsNewAccount_ProtoID>(
    stNotifyIsNewAccount_ProtoID_descriptor(), name, value);
}
enum stNotifyIsNewAccount_ProtoFunID {
  stNotifyIsNewAccount_ProtoFunID_FunID = 12
};
bool stNotifyIsNewAccount_ProtoFunID_IsValid(int value);
const stNotifyIsNewAccount_ProtoFunID stNotifyIsNewAccount_ProtoFunID_ProtoFunID_MIN = stNotifyIsNewAccount_ProtoFunID_FunID;
const stNotifyIsNewAccount_ProtoFunID stNotifyIsNewAccount_ProtoFunID_ProtoFunID_MAX = stNotifyIsNewAccount_ProtoFunID_FunID;
const int stNotifyIsNewAccount_ProtoFunID_ProtoFunID_ARRAYSIZE = stNotifyIsNewAccount_ProtoFunID_ProtoFunID_MAX + 1;

const ::google::protobuf::EnumDescriptor* stNotifyIsNewAccount_ProtoFunID_descriptor();
inline const ::std::string& stNotifyIsNewAccount_ProtoFunID_Name(stNotifyIsNewAccount_ProtoFunID value) {
  return ::google::protobuf::internal::NameOfEnum(
    stNotifyIsNewAccount_ProtoFunID_descriptor(), value);
}
inline bool stNotifyIsNewAccount_ProtoFunID_Parse(
    const ::std::string& name, stNotifyIsNewAccount_ProtoFunID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stNotifyIsNewAccount_ProtoFunID>(
    stNotifyIsNewAccount_ProtoFunID_descriptor(), name, value);
}
enum LOGIN_MOD {
  ReqLogin_req = 1,
  RetLoginSucess_rsp = 2,
  LoginError_rsp = 3
};
bool LOGIN_MOD_IsValid(int value);
const LOGIN_MOD LOGIN_MOD_MIN = ReqLogin_req;
const LOGIN_MOD LOGIN_MOD_MAX = LoginError_rsp;
const int LOGIN_MOD_ARRAYSIZE = LOGIN_MOD_MAX + 1;

const ::google::protobuf::EnumDescriptor* LOGIN_MOD_descriptor();
inline const ::std::string& LOGIN_MOD_Name(LOGIN_MOD value) {
  return ::google::protobuf::internal::NameOfEnum(
    LOGIN_MOD_descriptor(), value);
}
inline bool LOGIN_MOD_Parse(
    const ::std::string& name, LOGIN_MOD* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LOGIN_MOD>(
    LOGIN_MOD_descriptor(), name, value);
}
// ===================================================================

class ReqLogin : public ::google::protobuf::Message {
 public:
  ReqLogin();
  virtual ~ReqLogin();

  ReqLogin(const ReqLogin& from);

  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogin& default_instance();

  void Swap(ReqLogin* other);

  // implements Message ----------------------------------------------

  ReqLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogin& from);
  void MergeFrom(const ReqLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqLogin_ProtoModID ProtoModID;
  static const ProtoModID ModID = ReqLogin_ProtoModID_ModID;
  static inline bool ProtoModID_IsValid(int value) {
    return ReqLogin_ProtoModID_IsValid(value);
  }
  static const ProtoModID ProtoModID_MIN =
    ReqLogin_ProtoModID_ProtoModID_MIN;
  static const ProtoModID ProtoModID_MAX =
    ReqLogin_ProtoModID_ProtoModID_MAX;
  static const int ProtoModID_ARRAYSIZE =
    ReqLogin_ProtoModID_ProtoModID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoModID_descriptor() {
    return ReqLogin_ProtoModID_descriptor();
  }
  static inline const ::std::string& ProtoModID_Name(ProtoModID value) {
    return ReqLogin_ProtoModID_Name(value);
  }
  static inline bool ProtoModID_Parse(const ::std::string& name,
      ProtoModID* value) {
    return ReqLogin_ProtoModID_Parse(name, value);
  }

  typedef ReqLogin_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = ReqLogin_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return ReqLogin_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    ReqLogin_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    ReqLogin_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    ReqLogin_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return ReqLogin_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return ReqLogin_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return ReqLogin_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Login.ReqLogin)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static ReqLogin* default_instance_;
};
// -------------------------------------------------------------------

class RetLoginSucess : public ::google::protobuf::Message {
 public:
  RetLoginSucess();
  virtual ~RetLoginSucess();

  RetLoginSucess(const RetLoginSucess& from);

  inline RetLoginSucess& operator=(const RetLoginSucess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RetLoginSucess& default_instance();

  void Swap(RetLoginSucess* other);

  // implements Message ----------------------------------------------

  RetLoginSucess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RetLoginSucess& from);
  void MergeFrom(const RetLoginSucess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RetLoginSucess_ProtoModID ProtoModID;
  static const ProtoModID ModID = RetLoginSucess_ProtoModID_ModID;
  static inline bool ProtoModID_IsValid(int value) {
    return RetLoginSucess_ProtoModID_IsValid(value);
  }
  static const ProtoModID ProtoModID_MIN =
    RetLoginSucess_ProtoModID_ProtoModID_MIN;
  static const ProtoModID ProtoModID_MAX =
    RetLoginSucess_ProtoModID_ProtoModID_MAX;
  static const int ProtoModID_ARRAYSIZE =
    RetLoginSucess_ProtoModID_ProtoModID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoModID_descriptor() {
    return RetLoginSucess_ProtoModID_descriptor();
  }
  static inline const ::std::string& ProtoModID_Name(ProtoModID value) {
    return RetLoginSucess_ProtoModID_Name(value);
  }
  static inline bool ProtoModID_Parse(const ::std::string& name,
      ProtoModID* value) {
    return RetLoginSucess_ProtoModID_Parse(name, value);
  }

  typedef RetLoginSucess_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = RetLoginSucess_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return RetLoginSucess_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    RetLoginSucess_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    RetLoginSucess_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    RetLoginSucess_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return RetLoginSucess_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return RetLoginSucess_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return RetLoginSucess_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string ip = 2;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 2;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional string device = 3;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 3;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional uint32 opID = 4;
  inline bool has_opid() const;
  inline void clear_opid();
  static const int kOpIDFieldNumber = 4;
  inline ::google::protobuf::uint32 opid() const;
  inline void set_opid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.RetLoginSucess)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_opid();
  inline void clear_has_opid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* ip_;
  ::std::string* device_;
  ::google::protobuf::uint32 opid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static RetLoginSucess* default_instance_;
};
// -------------------------------------------------------------------

class LoginError : public ::google::protobuf::Message {
 public:
  LoginError();
  virtual ~LoginError();

  LoginError(const LoginError& from);

  inline LoginError& operator=(const LoginError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginError& default_instance();

  void Swap(LoginError* other);

  // implements Message ----------------------------------------------

  LoginError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginError& from);
  void MergeFrom(const LoginError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoginError_ErrorType ErrorType;
  static const ErrorType PASSWORD_WRONG = LoginError_ErrorType_PASSWORD_WRONG;
  static const ErrorType HAS_LOGIN_IN = LoginError_ErrorType_HAS_LOGIN_IN;
  static const ErrorType OTHER = LoginError_ErrorType_OTHER;
  static const ErrorType LOGIN_IN_OTHER_PLACE = LoginError_ErrorType_LOGIN_IN_OTHER_PLACE;
  static const ErrorType LOGIN_VERSION_TOO_LOW = LoginError_ErrorType_LOGIN_VERSION_TOO_LOW;
  static inline bool ErrorType_IsValid(int value) {
    return LoginError_ErrorType_IsValid(value);
  }
  static const ErrorType ErrorType_MIN =
    LoginError_ErrorType_ErrorType_MIN;
  static const ErrorType ErrorType_MAX =
    LoginError_ErrorType_ErrorType_MAX;
  static const int ErrorType_ARRAYSIZE =
    LoginError_ErrorType_ErrorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorType_descriptor() {
    return LoginError_ErrorType_descriptor();
  }
  static inline const ::std::string& ErrorType_Name(ErrorType value) {
    return LoginError_ErrorType_Name(value);
  }
  static inline bool ErrorType_Parse(const ::std::string& name,
      ErrorType* value) {
    return LoginError_ErrorType_Parse(name, value);
  }

  typedef LoginError_ProtoID ProtoID;
  static const ProtoID ModID = LoginError_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return LoginError_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    LoginError_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    LoginError_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    LoginError_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return LoginError_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return LoginError_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return LoginError_ProtoID_Parse(name, value);
  }

  typedef LoginError_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = LoginError_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return LoginError_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    LoginError_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    LoginError_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    LoginError_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return LoginError_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return LoginError_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return LoginError_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 errorType = 1;
  inline bool has_errortype() const;
  inline void clear_errortype();
  static const int kErrorTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 errortype() const;
  inline void set_errortype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.LoginError)
 private:
  inline void set_has_errortype();
  inline void clear_has_errortype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 errortype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static LoginError* default_instance_;
};
// -------------------------------------------------------------------

class ReqLoginGate : public ::google::protobuf::Message {
 public:
  ReqLoginGate();
  virtual ~ReqLoginGate();

  ReqLoginGate(const ReqLoginGate& from);

  inline ReqLoginGate& operator=(const ReqLoginGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLoginGate& default_instance();

  void Swap(ReqLoginGate* other);

  // implements Message ----------------------------------------------

  ReqLoginGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLoginGate& from);
  void MergeFrom(const ReqLoginGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReqLoginGate_ProtoID ProtoID;
  static const ProtoID ModID = ReqLoginGate_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return ReqLoginGate_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    ReqLoginGate_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    ReqLoginGate_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    ReqLoginGate_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return ReqLoginGate_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return ReqLoginGate_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return ReqLoginGate_ProtoID_Parse(name, value);
  }

  typedef ReqLoginGate_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = ReqLoginGate_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return ReqLoginGate_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    ReqLoginGate_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    ReqLoginGate_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    ReqLoginGate_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return ReqLoginGate_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return ReqLoginGate_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return ReqLoginGate_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string deviceID = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIDFieldNumber = 2;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 opID = 4;
  inline bool has_opid() const;
  inline void clear_opid();
  static const int kOpIDFieldNumber = 4;
  inline ::google::protobuf::uint32 opid() const;
  inline void set_opid(::google::protobuf::uint32 value);

  // optional uint32 clientVersion = 5;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 5;
  inline ::google::protobuf::uint32 clientversion() const;
  inline void set_clientversion(::google::protobuf::uint32 value);

  // optional uint32 serverID = 6;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIDFieldNumber = 6;
  inline ::google::protobuf::uint32 serverid() const;
  inline void set_serverid(::google::protobuf::uint32 value);

  // optional string extraData = 7;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtraDataFieldNumber = 7;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // optional uint32 sdkId = 8;
  inline bool has_sdkid() const;
  inline void clear_sdkid();
  static const int kSdkIdFieldNumber = 8;
  inline ::google::protobuf::uint32 sdkid() const;
  inline void set_sdkid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.ReqLoginGate)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_opid();
  inline void clear_has_opid();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_extradata();
  inline void clear_has_extradata();
  inline void set_has_sdkid();
  inline void clear_has_sdkid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* deviceid_;
  ::std::string* ip_;
  ::google::protobuf::uint32 opid_;
  ::google::protobuf::uint32 clientversion_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 serverid_;
  ::google::protobuf::uint32 sdkid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static ReqLoginGate* default_instance_;
};
// -------------------------------------------------------------------

class stReqServerTime : public ::google::protobuf::Message {
 public:
  stReqServerTime();
  virtual ~stReqServerTime();

  stReqServerTime(const stReqServerTime& from);

  inline stReqServerTime& operator=(const stReqServerTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stReqServerTime& default_instance();

  void Swap(stReqServerTime* other);

  // implements Message ----------------------------------------------

  stReqServerTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stReqServerTime& from);
  void MergeFrom(const stReqServerTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef stReqServerTime_ProtoID ProtoID;
  static const ProtoID ModID = stReqServerTime_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return stReqServerTime_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    stReqServerTime_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    stReqServerTime_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    stReqServerTime_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return stReqServerTime_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return stReqServerTime_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return stReqServerTime_ProtoID_Parse(name, value);
  }

  typedef stReqServerTime_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = stReqServerTime_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return stReqServerTime_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    stReqServerTime_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    stReqServerTime_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    stReqServerTime_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return stReqServerTime_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return stReqServerTime_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return stReqServerTime_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 flag = 1;
  inline bool has_flag() const;
  inline void clear_flag();
  static const int kFlagFieldNumber = 1;
  inline ::google::protobuf::uint32 flag() const;
  inline void set_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.stReqServerTime)
 private:
  inline void set_has_flag();
  inline void clear_has_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 flag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static stReqServerTime* default_instance_;
};
// -------------------------------------------------------------------

class stRetServerTime : public ::google::protobuf::Message {
 public:
  stRetServerTime();
  virtual ~stRetServerTime();

  stRetServerTime(const stRetServerTime& from);

  inline stRetServerTime& operator=(const stRetServerTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stRetServerTime& default_instance();

  void Swap(stRetServerTime* other);

  // implements Message ----------------------------------------------

  stRetServerTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stRetServerTime& from);
  void MergeFrom(const stRetServerTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef stRetServerTime_ProtoID ProtoID;
  static const ProtoID ModID = stRetServerTime_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return stRetServerTime_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    stRetServerTime_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    stRetServerTime_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    stRetServerTime_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return stRetServerTime_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return stRetServerTime_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return stRetServerTime_ProtoID_Parse(name, value);
  }

  typedef stRetServerTime_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = stRetServerTime_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return stRetServerTime_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    stRetServerTime_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    stRetServerTime_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    stRetServerTime_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return stRetServerTime_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return stRetServerTime_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return stRetServerTime_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 svrTime = 1;
  inline bool has_svrtime() const;
  inline void clear_svrtime();
  static const int kSvrTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 svrtime() const;
  inline void set_svrtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.stRetServerTime)
 private:
  inline void set_has_svrtime();
  inline void clear_has_svrtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 svrtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static stRetServerTime* default_instance_;
};
// -------------------------------------------------------------------

class stAutoLoginGate : public ::google::protobuf::Message {
 public:
  stAutoLoginGate();
  virtual ~stAutoLoginGate();

  stAutoLoginGate(const stAutoLoginGate& from);

  inline stAutoLoginGate& operator=(const stAutoLoginGate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stAutoLoginGate& default_instance();

  void Swap(stAutoLoginGate* other);

  // implements Message ----------------------------------------------

  stAutoLoginGate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stAutoLoginGate& from);
  void MergeFrom(const stAutoLoginGate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef stAutoLoginGate_ProtoID ProtoID;
  static const ProtoID ModID = stAutoLoginGate_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return stAutoLoginGate_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    stAutoLoginGate_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    stAutoLoginGate_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    stAutoLoginGate_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return stAutoLoginGate_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return stAutoLoginGate_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return stAutoLoginGate_ProtoID_Parse(name, value);
  }

  typedef stAutoLoginGate_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = stAutoLoginGate_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return stAutoLoginGate_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    stAutoLoginGate_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    stAutoLoginGate_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    stAutoLoginGate_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return stAutoLoginGate_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return stAutoLoginGate_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return stAutoLoginGate_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string deviceID = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIDFieldNumber = 2;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // optional uint32 opID = 4;
  inline bool has_opid() const;
  inline void clear_opid();
  static const int kOpIDFieldNumber = 4;
  inline ::google::protobuf::uint32 opid() const;
  inline void set_opid(::google::protobuf::uint32 value);

  // optional string extraData = 5;
  inline bool has_extradata() const;
  inline void clear_extradata();
  static const int kExtraDataFieldNumber = 5;
  inline const ::std::string& extradata() const;
  inline void set_extradata(const ::std::string& value);
  inline void set_extradata(const char* value);
  inline void set_extradata(const char* value, size_t size);
  inline ::std::string* mutable_extradata();
  inline ::std::string* release_extradata();
  inline void set_allocated_extradata(::std::string* extradata);

  // optional uint32 sdkId = 6;
  inline bool has_sdkid() const;
  inline void clear_sdkid();
  static const int kSdkIdFieldNumber = 6;
  inline ::google::protobuf::uint32 sdkid() const;
  inline void set_sdkid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.stAutoLoginGate)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_opid();
  inline void clear_has_opid();
  inline void set_has_extradata();
  inline void clear_has_extradata();
  inline void set_has_sdkid();
  inline void clear_has_sdkid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* deviceid_;
  ::std::string* ip_;
  ::std::string* extradata_;
  ::google::protobuf::uint32 opid_;
  ::google::protobuf::uint32 sdkid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static stAutoLoginGate* default_instance_;
};
// -------------------------------------------------------------------

class stNotifyRelogin : public ::google::protobuf::Message {
 public:
  stNotifyRelogin();
  virtual ~stNotifyRelogin();

  stNotifyRelogin(const stNotifyRelogin& from);

  inline stNotifyRelogin& operator=(const stNotifyRelogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stNotifyRelogin& default_instance();

  void Swap(stNotifyRelogin* other);

  // implements Message ----------------------------------------------

  stNotifyRelogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stNotifyRelogin& from);
  void MergeFrom(const stNotifyRelogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef stNotifyRelogin_ProtoID ProtoID;
  static const ProtoID ModID = stNotifyRelogin_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return stNotifyRelogin_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    stNotifyRelogin_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    stNotifyRelogin_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    stNotifyRelogin_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return stNotifyRelogin_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return stNotifyRelogin_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return stNotifyRelogin_ProtoID_Parse(name, value);
  }

  typedef stNotifyRelogin_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = stNotifyRelogin_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return stNotifyRelogin_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    stNotifyRelogin_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    stNotifyRelogin_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    stNotifyRelogin_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return stNotifyRelogin_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return stNotifyRelogin_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return stNotifyRelogin_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Login.stNotifyRelogin)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static stNotifyRelogin* default_instance_;
};
// -------------------------------------------------------------------

class stQueryPingValue : public ::google::protobuf::Message {
 public:
  stQueryPingValue();
  virtual ~stQueryPingValue();

  stQueryPingValue(const stQueryPingValue& from);

  inline stQueryPingValue& operator=(const stQueryPingValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stQueryPingValue& default_instance();

  void Swap(stQueryPingValue* other);

  // implements Message ----------------------------------------------

  stQueryPingValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stQueryPingValue& from);
  void MergeFrom(const stQueryPingValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef stQueryPingValue_ProtoID ProtoID;
  static const ProtoID ModID = stQueryPingValue_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return stQueryPingValue_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    stQueryPingValue_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    stQueryPingValue_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    stQueryPingValue_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return stQueryPingValue_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return stQueryPingValue_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return stQueryPingValue_ProtoID_Parse(name, value);
  }

  typedef stQueryPingValue_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = stQueryPingValue_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return stQueryPingValue_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    stQueryPingValue_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    stQueryPingValue_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    stQueryPingValue_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return stQueryPingValue_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return stQueryPingValue_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return stQueryPingValue_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 curTime = 1;
  inline bool has_curtime() const;
  inline void clear_curtime();
  static const int kCurTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 curtime() const;
  inline void set_curtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.stQueryPingValue)
 private:
  inline void set_has_curtime();
  inline void clear_has_curtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 curtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static stQueryPingValue* default_instance_;
};
// -------------------------------------------------------------------

class stReqClientTime : public ::google::protobuf::Message {
 public:
  stReqClientTime();
  virtual ~stReqClientTime();

  stReqClientTime(const stReqClientTime& from);

  inline stReqClientTime& operator=(const stReqClientTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stReqClientTime& default_instance();

  void Swap(stReqClientTime* other);

  // implements Message ----------------------------------------------

  stReqClientTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stReqClientTime& from);
  void MergeFrom(const stReqClientTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef stReqClientTime_ProtoID ProtoID;
  static const ProtoID ModID = stReqClientTime_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return stReqClientTime_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    stReqClientTime_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    stReqClientTime_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    stReqClientTime_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return stReqClientTime_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return stReqClientTime_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return stReqClientTime_ProtoID_Parse(name, value);
  }

  typedef stReqClientTime_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = stReqClientTime_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return stReqClientTime_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    stReqClientTime_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    stReqClientTime_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    stReqClientTime_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return stReqClientTime_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return stReqClientTime_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return stReqClientTime_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 curTime = 1;
  inline bool has_curtime() const;
  inline void clear_curtime();
  static const int kCurTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 curtime() const;
  inline void set_curtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.stReqClientTime)
 private:
  inline void set_has_curtime();
  inline void clear_has_curtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 curtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static stReqClientTime* default_instance_;
};
// -------------------------------------------------------------------

class stSendClient2Svr : public ::google::protobuf::Message {
 public:
  stSendClient2Svr();
  virtual ~stSendClient2Svr();

  stSendClient2Svr(const stSendClient2Svr& from);

  inline stSendClient2Svr& operator=(const stSendClient2Svr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stSendClient2Svr& default_instance();

  void Swap(stSendClient2Svr* other);

  // implements Message ----------------------------------------------

  stSendClient2Svr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stSendClient2Svr& from);
  void MergeFrom(const stSendClient2Svr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef stSendClient2Svr_ProtoID ProtoID;
  static const ProtoID ModID = stSendClient2Svr_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return stSendClient2Svr_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    stSendClient2Svr_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    stSendClient2Svr_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    stSendClient2Svr_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return stSendClient2Svr_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return stSendClient2Svr_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return stSendClient2Svr_ProtoID_Parse(name, value);
  }

  typedef stSendClient2Svr_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = stSendClient2Svr_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return stSendClient2Svr_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    stSendClient2Svr_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    stSendClient2Svr_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    stSendClient2Svr_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return stSendClient2Svr_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return stSendClient2Svr_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return stSendClient2Svr_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 curTime = 1;
  inline bool has_curtime() const;
  inline void clear_curtime();
  static const int kCurTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 curtime() const;
  inline void set_curtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Login.stSendClient2Svr)
 private:
  inline void set_has_curtime();
  inline void clear_has_curtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 curtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static stSendClient2Svr* default_instance_;
};
// -------------------------------------------------------------------

class stNotifyIsNewAccount : public ::google::protobuf::Message {
 public:
  stNotifyIsNewAccount();
  virtual ~stNotifyIsNewAccount();

  stNotifyIsNewAccount(const stNotifyIsNewAccount& from);

  inline stNotifyIsNewAccount& operator=(const stNotifyIsNewAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stNotifyIsNewAccount& default_instance();

  void Swap(stNotifyIsNewAccount* other);

  // implements Message ----------------------------------------------

  stNotifyIsNewAccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stNotifyIsNewAccount& from);
  void MergeFrom(const stNotifyIsNewAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef stNotifyIsNewAccount_ProtoID ProtoID;
  static const ProtoID ModID = stNotifyIsNewAccount_ProtoID_ModID;
  static inline bool ProtoID_IsValid(int value) {
    return stNotifyIsNewAccount_ProtoID_IsValid(value);
  }
  static const ProtoID ProtoID_MIN =
    stNotifyIsNewAccount_ProtoID_ProtoID_MIN;
  static const ProtoID ProtoID_MAX =
    stNotifyIsNewAccount_ProtoID_ProtoID_MAX;
  static const int ProtoID_ARRAYSIZE =
    stNotifyIsNewAccount_ProtoID_ProtoID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoID_descriptor() {
    return stNotifyIsNewAccount_ProtoID_descriptor();
  }
  static inline const ::std::string& ProtoID_Name(ProtoID value) {
    return stNotifyIsNewAccount_ProtoID_Name(value);
  }
  static inline bool ProtoID_Parse(const ::std::string& name,
      ProtoID* value) {
    return stNotifyIsNewAccount_ProtoID_Parse(name, value);
  }

  typedef stNotifyIsNewAccount_ProtoFunID ProtoFunID;
  static const ProtoFunID FunID = stNotifyIsNewAccount_ProtoFunID_FunID;
  static inline bool ProtoFunID_IsValid(int value) {
    return stNotifyIsNewAccount_ProtoFunID_IsValid(value);
  }
  static const ProtoFunID ProtoFunID_MIN =
    stNotifyIsNewAccount_ProtoFunID_ProtoFunID_MIN;
  static const ProtoFunID ProtoFunID_MAX =
    stNotifyIsNewAccount_ProtoFunID_ProtoFunID_MAX;
  static const int ProtoFunID_ARRAYSIZE =
    stNotifyIsNewAccount_ProtoFunID_ProtoFunID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoFunID_descriptor() {
    return stNotifyIsNewAccount_ProtoFunID_descriptor();
  }
  static inline const ::std::string& ProtoFunID_Name(ProtoFunID value) {
    return stNotifyIsNewAccount_ProtoFunID_Name(value);
  }
  static inline bool ProtoFunID_Parse(const ::std::string& name,
      ProtoFunID* value) {
    return stNotifyIsNewAccount_ProtoFunID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool isNewAcc = 1;
  inline bool has_isnewacc() const;
  inline void clear_isnewacc();
  static const int kIsNewAccFieldNumber = 1;
  inline bool isnewacc() const;
  inline void set_isnewacc(bool value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:Login.stNotifyIsNewAccount)
 private:
  inline void set_has_isnewacc();
  inline void clear_has_isnewacc();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  bool isnewacc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Login_2eproto();
  friend void protobuf_AssignDesc_Login_2eproto();
  friend void protobuf_ShutdownFile_Login_2eproto();

  void InitAsDefaultInstance();
  static stNotifyIsNewAccount* default_instance_;
};
// ===================================================================


// ===================================================================

// ReqLogin

// optional string account = 1;
inline bool ReqLogin::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogin::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ReqLogin::account() const {
  return *account_;
}
inline void ReqLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqLogin::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ReqLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 2;
inline bool ReqLogin::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLogin::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLogin::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLogin::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& ReqLogin::password() const {
  return *password_;
}
inline void ReqLogin::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ReqLogin::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void ReqLogin::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* ReqLogin::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RetLoginSucess

// optional string token = 1;
inline bool RetLoginSucess::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RetLoginSucess::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RetLoginSucess::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RetLoginSucess::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& RetLoginSucess::token() const {
  return *token_;
}
inline void RetLoginSucess::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RetLoginSucess::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RetLoginSucess::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetLoginSucess::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* RetLoginSucess::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RetLoginSucess::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 2;
inline bool RetLoginSucess::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RetLoginSucess::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RetLoginSucess::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RetLoginSucess::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& RetLoginSucess::ip() const {
  return *ip_;
}
inline void RetLoginSucess::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RetLoginSucess::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void RetLoginSucess::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetLoginSucess::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* RetLoginSucess::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RetLoginSucess::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string device = 3;
inline bool RetLoginSucess::has_device() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RetLoginSucess::set_has_device() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RetLoginSucess::clear_has_device() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RetLoginSucess::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& RetLoginSucess::device() const {
  return *device_;
}
inline void RetLoginSucess::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void RetLoginSucess::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void RetLoginSucess::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RetLoginSucess::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* RetLoginSucess::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RetLoginSucess::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 opID = 4;
inline bool RetLoginSucess::has_opid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RetLoginSucess::set_has_opid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RetLoginSucess::clear_has_opid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RetLoginSucess::clear_opid() {
  opid_ = 0u;
  clear_has_opid();
}
inline ::google::protobuf::uint32 RetLoginSucess::opid() const {
  return opid_;
}
inline void RetLoginSucess::set_opid(::google::protobuf::uint32 value) {
  set_has_opid();
  opid_ = value;
}

// -------------------------------------------------------------------

// LoginError

// optional uint32 errorType = 1;
inline bool LoginError::has_errortype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginError::set_has_errortype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginError::clear_has_errortype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginError::clear_errortype() {
  errortype_ = 0u;
  clear_has_errortype();
}
inline ::google::protobuf::uint32 LoginError::errortype() const {
  return errortype_;
}
inline void LoginError::set_errortype(::google::protobuf::uint32 value) {
  set_has_errortype();
  errortype_ = value;
}

// -------------------------------------------------------------------

// ReqLoginGate

// optional string token = 1;
inline bool ReqLoginGate::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLoginGate::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLoginGate::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLoginGate::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ReqLoginGate::token() const {
  return *token_;
}
inline void ReqLoginGate::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqLoginGate::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ReqLoginGate::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLoginGate::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ReqLoginGate::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLoginGate::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceID = 2;
inline bool ReqLoginGate::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLoginGate::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLoginGate::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLoginGate::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& ReqLoginGate::deviceid() const {
  return *deviceid_;
}
inline void ReqLoginGate::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void ReqLoginGate::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void ReqLoginGate::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLoginGate::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* ReqLoginGate::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLoginGate::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 3;
inline bool ReqLoginGate::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLoginGate::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLoginGate::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLoginGate::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& ReqLoginGate::ip() const {
  return *ip_;
}
inline void ReqLoginGate::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ReqLoginGate::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void ReqLoginGate::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLoginGate::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* ReqLoginGate::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLoginGate::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 opID = 4;
inline bool ReqLoginGate::has_opid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqLoginGate::set_has_opid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqLoginGate::clear_has_opid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqLoginGate::clear_opid() {
  opid_ = 0u;
  clear_has_opid();
}
inline ::google::protobuf::uint32 ReqLoginGate::opid() const {
  return opid_;
}
inline void ReqLoginGate::set_opid(::google::protobuf::uint32 value) {
  set_has_opid();
  opid_ = value;
}

// optional uint32 clientVersion = 5;
inline bool ReqLoginGate::has_clientversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqLoginGate::set_has_clientversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqLoginGate::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqLoginGate::clear_clientversion() {
  clientversion_ = 0u;
  clear_has_clientversion();
}
inline ::google::protobuf::uint32 ReqLoginGate::clientversion() const {
  return clientversion_;
}
inline void ReqLoginGate::set_clientversion(::google::protobuf::uint32 value) {
  set_has_clientversion();
  clientversion_ = value;
}

// optional uint32 serverID = 6;
inline bool ReqLoginGate::has_serverid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqLoginGate::set_has_serverid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqLoginGate::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqLoginGate::clear_serverid() {
  serverid_ = 0u;
  clear_has_serverid();
}
inline ::google::protobuf::uint32 ReqLoginGate::serverid() const {
  return serverid_;
}
inline void ReqLoginGate::set_serverid(::google::protobuf::uint32 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional string extraData = 7;
inline bool ReqLoginGate::has_extradata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqLoginGate::set_has_extradata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqLoginGate::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqLoginGate::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& ReqLoginGate::extradata() const {
  return *extradata_;
}
inline void ReqLoginGate::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void ReqLoginGate::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void ReqLoginGate::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLoginGate::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* ReqLoginGate::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLoginGate::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sdkId = 8;
inline bool ReqLoginGate::has_sdkid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqLoginGate::set_has_sdkid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqLoginGate::clear_has_sdkid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqLoginGate::clear_sdkid() {
  sdkid_ = 0u;
  clear_has_sdkid();
}
inline ::google::protobuf::uint32 ReqLoginGate::sdkid() const {
  return sdkid_;
}
inline void ReqLoginGate::set_sdkid(::google::protobuf::uint32 value) {
  set_has_sdkid();
  sdkid_ = value;
}

// -------------------------------------------------------------------

// stReqServerTime

// optional uint32 flag = 1;
inline bool stReqServerTime::has_flag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stReqServerTime::set_has_flag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stReqServerTime::clear_has_flag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stReqServerTime::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 stReqServerTime::flag() const {
  return flag_;
}
inline void stReqServerTime::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
}

// -------------------------------------------------------------------

// stRetServerTime

// optional uint32 svrTime = 1;
inline bool stRetServerTime::has_svrtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stRetServerTime::set_has_svrtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stRetServerTime::clear_has_svrtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stRetServerTime::clear_svrtime() {
  svrtime_ = 0u;
  clear_has_svrtime();
}
inline ::google::protobuf::uint32 stRetServerTime::svrtime() const {
  return svrtime_;
}
inline void stRetServerTime::set_svrtime(::google::protobuf::uint32 value) {
  set_has_svrtime();
  svrtime_ = value;
}

// -------------------------------------------------------------------

// stAutoLoginGate

// optional string token = 1;
inline bool stAutoLoginGate::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stAutoLoginGate::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stAutoLoginGate::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stAutoLoginGate::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& stAutoLoginGate::token() const {
  return *token_;
}
inline void stAutoLoginGate::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void stAutoLoginGate::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void stAutoLoginGate::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* stAutoLoginGate::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* stAutoLoginGate::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void stAutoLoginGate::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string deviceID = 2;
inline bool stAutoLoginGate::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stAutoLoginGate::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stAutoLoginGate::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stAutoLoginGate::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& stAutoLoginGate::deviceid() const {
  return *deviceid_;
}
inline void stAutoLoginGate::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void stAutoLoginGate::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void stAutoLoginGate::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* stAutoLoginGate::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* stAutoLoginGate::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void stAutoLoginGate::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 3;
inline bool stAutoLoginGate::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stAutoLoginGate::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stAutoLoginGate::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stAutoLoginGate::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& stAutoLoginGate::ip() const {
  return *ip_;
}
inline void stAutoLoginGate::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void stAutoLoginGate::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void stAutoLoginGate::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* stAutoLoginGate::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* stAutoLoginGate::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void stAutoLoginGate::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 opID = 4;
inline bool stAutoLoginGate::has_opid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void stAutoLoginGate::set_has_opid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void stAutoLoginGate::clear_has_opid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void stAutoLoginGate::clear_opid() {
  opid_ = 0u;
  clear_has_opid();
}
inline ::google::protobuf::uint32 stAutoLoginGate::opid() const {
  return opid_;
}
inline void stAutoLoginGate::set_opid(::google::protobuf::uint32 value) {
  set_has_opid();
  opid_ = value;
}

// optional string extraData = 5;
inline bool stAutoLoginGate::has_extradata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void stAutoLoginGate::set_has_extradata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void stAutoLoginGate::clear_has_extradata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void stAutoLoginGate::clear_extradata() {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    extradata_->clear();
  }
  clear_has_extradata();
}
inline const ::std::string& stAutoLoginGate::extradata() const {
  return *extradata_;
}
inline void stAutoLoginGate::set_extradata(const ::std::string& value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void stAutoLoginGate::set_extradata(const char* value) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(value);
}
inline void stAutoLoginGate::set_extradata(const char* value, size_t size) {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  extradata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* stAutoLoginGate::mutable_extradata() {
  set_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    extradata_ = new ::std::string;
  }
  return extradata_;
}
inline ::std::string* stAutoLoginGate::release_extradata() {
  clear_has_extradata();
  if (extradata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extradata_;
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void stAutoLoginGate::set_allocated_extradata(::std::string* extradata) {
  if (extradata_ != &::google::protobuf::internal::kEmptyString) {
    delete extradata_;
  }
  if (extradata) {
    set_has_extradata();
    extradata_ = extradata;
  } else {
    clear_has_extradata();
    extradata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sdkId = 6;
inline bool stAutoLoginGate::has_sdkid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void stAutoLoginGate::set_has_sdkid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void stAutoLoginGate::clear_has_sdkid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void stAutoLoginGate::clear_sdkid() {
  sdkid_ = 0u;
  clear_has_sdkid();
}
inline ::google::protobuf::uint32 stAutoLoginGate::sdkid() const {
  return sdkid_;
}
inline void stAutoLoginGate::set_sdkid(::google::protobuf::uint32 value) {
  set_has_sdkid();
  sdkid_ = value;
}

// -------------------------------------------------------------------

// stNotifyRelogin

// -------------------------------------------------------------------

// stQueryPingValue

// optional uint32 curTime = 1;
inline bool stQueryPingValue::has_curtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stQueryPingValue::set_has_curtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stQueryPingValue::clear_has_curtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stQueryPingValue::clear_curtime() {
  curtime_ = 0u;
  clear_has_curtime();
}
inline ::google::protobuf::uint32 stQueryPingValue::curtime() const {
  return curtime_;
}
inline void stQueryPingValue::set_curtime(::google::protobuf::uint32 value) {
  set_has_curtime();
  curtime_ = value;
}

// -------------------------------------------------------------------

// stReqClientTime

// optional uint32 curTime = 1;
inline bool stReqClientTime::has_curtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stReqClientTime::set_has_curtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stReqClientTime::clear_has_curtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stReqClientTime::clear_curtime() {
  curtime_ = 0u;
  clear_has_curtime();
}
inline ::google::protobuf::uint32 stReqClientTime::curtime() const {
  return curtime_;
}
inline void stReqClientTime::set_curtime(::google::protobuf::uint32 value) {
  set_has_curtime();
  curtime_ = value;
}

// -------------------------------------------------------------------

// stSendClient2Svr

// optional uint32 curTime = 1;
inline bool stSendClient2Svr::has_curtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stSendClient2Svr::set_has_curtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stSendClient2Svr::clear_has_curtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stSendClient2Svr::clear_curtime() {
  curtime_ = 0u;
  clear_has_curtime();
}
inline ::google::protobuf::uint32 stSendClient2Svr::curtime() const {
  return curtime_;
}
inline void stSendClient2Svr::set_curtime(::google::protobuf::uint32 value) {
  set_has_curtime();
  curtime_ = value;
}

// -------------------------------------------------------------------

// stNotifyIsNewAccount

// optional bool isNewAcc = 1;
inline bool stNotifyIsNewAccount::has_isnewacc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stNotifyIsNewAccount::set_has_isnewacc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stNotifyIsNewAccount::clear_has_isnewacc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stNotifyIsNewAccount::clear_isnewacc() {
  isnewacc_ = false;
  clear_has_isnewacc();
}
inline bool stNotifyIsNewAccount::isnewacc() const {
  return isnewacc_;
}
inline void stNotifyIsNewAccount::set_isnewacc(bool value) {
  set_has_isnewacc();
  isnewacc_ = value;
}

// optional string account = 2;
inline bool stNotifyIsNewAccount::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stNotifyIsNewAccount::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stNotifyIsNewAccount::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stNotifyIsNewAccount::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& stNotifyIsNewAccount::account() const {
  return *account_;
}
inline void stNotifyIsNewAccount::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void stNotifyIsNewAccount::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void stNotifyIsNewAccount::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* stNotifyIsNewAccount::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* stNotifyIsNewAccount::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void stNotifyIsNewAccount::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Login

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::ReqLogin_ProtoModID>() {
  return ::Login::ReqLogin_ProtoModID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::ReqLogin_ProtoFunID>() {
  return ::Login::ReqLogin_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::RetLoginSucess_ProtoModID>() {
  return ::Login::RetLoginSucess_ProtoModID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::RetLoginSucess_ProtoFunID>() {
  return ::Login::RetLoginSucess_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::LoginError_ErrorType>() {
  return ::Login::LoginError_ErrorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::LoginError_ProtoID>() {
  return ::Login::LoginError_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::LoginError_ProtoFunID>() {
  return ::Login::LoginError_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::ReqLoginGate_ProtoID>() {
  return ::Login::ReqLoginGate_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::ReqLoginGate_ProtoFunID>() {
  return ::Login::ReqLoginGate_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stReqServerTime_ProtoID>() {
  return ::Login::stReqServerTime_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stReqServerTime_ProtoFunID>() {
  return ::Login::stReqServerTime_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stRetServerTime_ProtoID>() {
  return ::Login::stRetServerTime_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stRetServerTime_ProtoFunID>() {
  return ::Login::stRetServerTime_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stAutoLoginGate_ProtoID>() {
  return ::Login::stAutoLoginGate_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stAutoLoginGate_ProtoFunID>() {
  return ::Login::stAutoLoginGate_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stNotifyRelogin_ProtoID>() {
  return ::Login::stNotifyRelogin_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stNotifyRelogin_ProtoFunID>() {
  return ::Login::stNotifyRelogin_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stQueryPingValue_ProtoID>() {
  return ::Login::stQueryPingValue_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stQueryPingValue_ProtoFunID>() {
  return ::Login::stQueryPingValue_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stReqClientTime_ProtoID>() {
  return ::Login::stReqClientTime_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stReqClientTime_ProtoFunID>() {
  return ::Login::stReqClientTime_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stSendClient2Svr_ProtoID>() {
  return ::Login::stSendClient2Svr_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stSendClient2Svr_ProtoFunID>() {
  return ::Login::stSendClient2Svr_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stNotifyIsNewAccount_ProtoID>() {
  return ::Login::stNotifyIsNewAccount_ProtoID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::stNotifyIsNewAccount_ProtoFunID>() {
  return ::Login::stNotifyIsNewAccount_ProtoFunID_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Login::LOGIN_MOD>() {
  return ::Login::LOGIN_MOD_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Login_2eproto__INCLUDED
